// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/dialogflow/v2beta1/session.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import <googleapis/Session.pbobjc.h>
#import <googleapis/Annotations.pbobjc.h>
#import <googleapis/AudioConfig.pbobjc.h>
#import <googleapis/Context.pbobjc.h>
#import <googleapis/Intent.pbobjc.h>
#import <googleapis/SessionEntityType.pbobjc.h>
#import <googleapis/Status.pbobjc.h>
#import <googleapis/Latlng.pbobjc.h>
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - DFSessionRoot

@implementation DFSessionRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - DFSessionRoot_FileDescriptor

static GPBFileDescriptor *DFSessionRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.cloud.dialogflow.v2beta1"
                                                 objcPrefix:@"DF"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum DFAudioEncoding

GPBEnumDescriptor *DFAudioEncoding_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AudioEncodingUnspecified\000AudioEncodingLi"
        "near16\000AudioEncodingFlac\000AudioEncodingMu"
        "law\000AudioEncodingAmr\000AudioEncodingAmrWb\000"
        "AudioEncodingOggOpus\000AudioEncodingSpeexW"
        "ithHeaderByte\000";
    static const int32_t values[] = {
        DFAudioEncoding_AudioEncodingUnspecified,
        DFAudioEncoding_AudioEncodingLinear16,
        DFAudioEncoding_AudioEncodingFlac,
        DFAudioEncoding_AudioEncodingMulaw,
        DFAudioEncoding_AudioEncodingAmr,
        DFAudioEncoding_AudioEncodingAmrWb,
        DFAudioEncoding_AudioEncodingOggOpus,
        DFAudioEncoding_AudioEncodingSpeexWithHeaderByte,
    };
    static const char *extraTextFormatInfo = "\001\001e\350\346\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DFAudioEncoding)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DFAudioEncoding_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DFAudioEncoding_IsValidValue(int32_t value__) {
  switch (value__) {
    case DFAudioEncoding_AudioEncodingUnspecified:
    case DFAudioEncoding_AudioEncodingLinear16:
    case DFAudioEncoding_AudioEncodingFlac:
    case DFAudioEncoding_AudioEncodingMulaw:
    case DFAudioEncoding_AudioEncodingAmr:
    case DFAudioEncoding_AudioEncodingAmrWb:
    case DFAudioEncoding_AudioEncodingOggOpus:
    case DFAudioEncoding_AudioEncodingSpeexWithHeaderByte:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DFDetectIntentRequest

@implementation DFDetectIntentRequest

@dynamic session;
@dynamic hasQueryParams, queryParams;
@dynamic hasQueryInput, queryInput;
@dynamic hasOutputAudioConfig, outputAudioConfig;
@dynamic inputAudio;

typedef struct DFDetectIntentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  DFQueryParameters *queryParams;
  DFQueryInput *queryInput;
  DFOutputAudioConfig *outputAudioConfig;
  NSData *inputAudio;
} DFDetectIntentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = DFDetectIntentRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFDetectIntentRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "queryParams",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryParameters),
        .number = DFDetectIntentRequest_FieldNumber_QueryParams,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFDetectIntentRequest__storage_, queryParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queryInput",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryInput),
        .number = DFDetectIntentRequest_FieldNumber_QueryInput,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFDetectIntentRequest__storage_, queryInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputAudioConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(DFOutputAudioConfig),
        .number = DFDetectIntentRequest_FieldNumber_OutputAudioConfig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DFDetectIntentRequest__storage_, outputAudioConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inputAudio",
        .dataTypeSpecific.className = NULL,
        .number = DFDetectIntentRequest_FieldNumber_InputAudio,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFDetectIntentRequest__storage_, inputAudio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFDetectIntentRequest class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFDetectIntentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFDetectIntentResponse

@implementation DFDetectIntentResponse

@dynamic responseId;
@dynamic hasQueryResult, queryResult;
@dynamic alternativeQueryResultsArray, alternativeQueryResultsArray_Count;
@dynamic hasWebhookStatus, webhookStatus;
@dynamic outputAudio;
@dynamic hasOutputAudioConfig, outputAudioConfig;

typedef struct DFDetectIntentResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *responseId;
  DFQueryResult *queryResult;
  Status *webhookStatus;
  NSData *outputAudio;
  NSMutableArray *alternativeQueryResultsArray;
  DFOutputAudioConfig *outputAudioConfig;
} DFDetectIntentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseId",
        .dataTypeSpecific.className = NULL,
        .number = DFDetectIntentResponse_FieldNumber_ResponseId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFDetectIntentResponse__storage_, responseId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "queryResult",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryResult),
        .number = DFDetectIntentResponse_FieldNumber_QueryResult,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFDetectIntentResponse__storage_, queryResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webhookStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(Status),
        .number = DFDetectIntentResponse_FieldNumber_WebhookStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFDetectIntentResponse__storage_, webhookStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputAudio",
        .dataTypeSpecific.className = NULL,
        .number = DFDetectIntentResponse_FieldNumber_OutputAudio,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DFDetectIntentResponse__storage_, outputAudio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "alternativeQueryResultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryResult),
        .number = DFDetectIntentResponse_FieldNumber_AlternativeQueryResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFDetectIntentResponse__storage_, alternativeQueryResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputAudioConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(DFOutputAudioConfig),
        .number = DFDetectIntentResponse_FieldNumber_OutputAudioConfig,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFDetectIntentResponse__storage_, outputAudioConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFDetectIntentResponse class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFDetectIntentResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFQueryParameters

@implementation DFQueryParameters

@dynamic timeZone;
@dynamic hasGeoLocation, geoLocation;
@dynamic contextsArray, contextsArray_Count;
@dynamic resetContexts;
@dynamic sessionEntityTypesArray, sessionEntityTypesArray_Count;
@dynamic hasPayload, payload;
@dynamic knowledgeBaseNamesArray, knowledgeBaseNamesArray_Count;
@dynamic hasSentimentAnalysisRequestConfig, sentimentAnalysisRequestConfig;

typedef struct DFQueryParameters__storage_ {
  uint32_t _has_storage_[1];
  NSString *timeZone;
  GTPLatLng *geoLocation;
  NSMutableArray *contextsArray;
  NSMutableArray *sessionEntityTypesArray;
  GPBStruct *payload;
  DFSentimentAnalysisRequestConfig *sentimentAnalysisRequestConfig;
  NSMutableArray *knowledgeBaseNamesArray;
} DFQueryParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryParameters_FieldNumber_TimeZone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, timeZone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "geoLocation",
        .dataTypeSpecific.className = GPBStringifySymbol(GTPLatLng),
        .number = DFQueryParameters_FieldNumber_GeoLocation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, geoLocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contextsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFContext),
        .number = DFQueryParameters_FieldNumber_ContextsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, contextsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resetContexts",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryParameters_FieldNumber_ResetContexts,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sessionEntityTypesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFSessionEntityType),
        .number = DFQueryParameters_FieldNumber_SessionEntityTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, sessionEntityTypesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = DFQueryParameters_FieldNumber_Payload,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sentimentAnalysisRequestConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(DFSentimentAnalysisRequestConfig),
        .number = DFQueryParameters_FieldNumber_SentimentAnalysisRequestConfig,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, sentimentAnalysisRequestConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "knowledgeBaseNamesArray",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryParameters_FieldNumber_KnowledgeBaseNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFQueryParameters__storage_, knowledgeBaseNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFQueryParameters class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFQueryParameters__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFQueryInput

@implementation DFQueryInput

@dynamic inputOneOfCase;
@dynamic audioConfig;
@dynamic text;
@dynamic event;

typedef struct DFQueryInput__storage_ {
  uint32_t _has_storage_[2];
  DFInputAudioConfig *audioConfig;
  DFTextInput *text;
  DFEventInput *event;
} DFQueryInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(DFInputAudioConfig),
        .number = DFQueryInput_FieldNumber_AudioConfig,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DFQueryInput__storage_, audioConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(DFTextInput),
        .number = DFQueryInput_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DFQueryInput__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "event",
        .dataTypeSpecific.className = GPBStringifySymbol(DFEventInput),
        .number = DFQueryInput_FieldNumber_Event,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DFQueryInput__storage_, event),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFQueryInput class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFQueryInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "input",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DFQueryInput_ClearInputOneOfCase(DFQueryInput *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - DFQueryResult

@implementation DFQueryResult

@dynamic queryText;
@dynamic languageCode;
@dynamic speechRecognitionConfidence;
@dynamic action;
@dynamic hasParameters, parameters;
@dynamic allRequiredParamsPresent;
@dynamic fulfillmentText;
@dynamic fulfillmentMessagesArray, fulfillmentMessagesArray_Count;
@dynamic webhookSource;
@dynamic hasWebhookPayload, webhookPayload;
@dynamic outputContextsArray, outputContextsArray_Count;
@dynamic hasIntent, intent;
@dynamic intentDetectionConfidence;
@dynamic hasDiagnosticInfo, diagnosticInfo;
@dynamic hasSentimentAnalysisResult, sentimentAnalysisResult;
@dynamic hasKnowledgeAnswers, knowledgeAnswers;

typedef struct DFQueryResult__storage_ {
  uint32_t _has_storage_[1];
  float speechRecognitionConfidence;
  float intentDetectionConfidence;
  NSString *queryText;
  NSString *action;
  GPBStruct *parameters;
  NSString *fulfillmentText;
  NSMutableArray *fulfillmentMessagesArray;
  NSString *webhookSource;
  GPBStruct *webhookPayload;
  NSMutableArray *outputContextsArray;
  DFIntent *intent;
  GPBStruct *diagnosticInfo;
  NSString *languageCode;
  DFSentimentAnalysisResult *sentimentAnalysisResult;
  DFKnowledgeAnswers *knowledgeAnswers;
} DFQueryResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryText",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_QueryText,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, queryText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "speechRecognitionConfidence",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_SpeechRecognitionConfidence,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, speechRecognitionConfidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "action",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_Action,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parameters",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = DFQueryResult_FieldNumber_Parameters,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, parameters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "allRequiredParamsPresent",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_AllRequiredParamsPresent,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fulfillmentText",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_FulfillmentText,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, fulfillmentText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fulfillmentMessagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFIntent_Message),
        .number = DFQueryResult_FieldNumber_FulfillmentMessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, fulfillmentMessagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webhookSource",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_WebhookSource,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, webhookSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "webhookPayload",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = DFQueryResult_FieldNumber_WebhookPayload,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, webhookPayload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputContextsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFContext),
        .number = DFQueryResult_FieldNumber_OutputContextsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, outputContextsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "intent",
        .dataTypeSpecific.className = GPBStringifySymbol(DFIntent),
        .number = DFQueryResult_FieldNumber_Intent,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, intent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "intentDetectionConfidence",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_IntentDetectionConfidence,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, intentDetectionConfidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "diagnosticInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = DFQueryResult_FieldNumber_DiagnosticInfo,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, diagnosticInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = DFQueryResult_FieldNumber_LanguageCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sentimentAnalysisResult",
        .dataTypeSpecific.className = GPBStringifySymbol(DFSentimentAnalysisResult),
        .number = DFQueryResult_FieldNumber_SentimentAnalysisResult,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, sentimentAnalysisResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "knowledgeAnswers",
        .dataTypeSpecific.className = GPBStringifySymbol(DFKnowledgeAnswers),
        .number = DFQueryResult_FieldNumber_KnowledgeAnswers,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DFQueryResult__storage_, knowledgeAnswers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFQueryResult class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFQueryResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFKnowledgeAnswers

@implementation DFKnowledgeAnswers

@dynamic answersArray, answersArray_Count;

typedef struct DFKnowledgeAnswers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *answersArray;
} DFKnowledgeAnswers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "answersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFKnowledgeAnswers_Answer),
        .number = DFKnowledgeAnswers_FieldNumber_AnswersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFKnowledgeAnswers__storage_, answersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFKnowledgeAnswers class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFKnowledgeAnswers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFKnowledgeAnswers_Answer

@implementation DFKnowledgeAnswers_Answer

@dynamic source;
@dynamic faqQuestion;
@dynamic answer;
@dynamic matchConfidenceLevel;
@dynamic matchConfidence;

typedef struct DFKnowledgeAnswers_Answer__storage_ {
  uint32_t _has_storage_[1];
  DFKnowledgeAnswers_Answer_MatchConfidenceLevel matchConfidenceLevel;
  float matchConfidence;
  NSString *source;
  NSString *faqQuestion;
  NSString *answer;
} DFKnowledgeAnswers_Answer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = DFKnowledgeAnswers_Answer_FieldNumber_Source,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFKnowledgeAnswers_Answer__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faqQuestion",
        .dataTypeSpecific.className = NULL,
        .number = DFKnowledgeAnswers_Answer_FieldNumber_FaqQuestion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFKnowledgeAnswers_Answer__storage_, faqQuestion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "answer",
        .dataTypeSpecific.className = NULL,
        .number = DFKnowledgeAnswers_Answer_FieldNumber_Answer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFKnowledgeAnswers_Answer__storage_, answer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "matchConfidenceLevel",
        .dataTypeSpecific.enumDescFunc = DFKnowledgeAnswers_Answer_MatchConfidenceLevel_EnumDescriptor,
        .number = DFKnowledgeAnswers_Answer_FieldNumber_MatchConfidenceLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DFKnowledgeAnswers_Answer__storage_, matchConfidenceLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "matchConfidence",
        .dataTypeSpecific.className = NULL,
        .number = DFKnowledgeAnswers_Answer_FieldNumber_MatchConfidence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFKnowledgeAnswers_Answer__storage_, matchConfidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFKnowledgeAnswers_Answer class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFKnowledgeAnswers_Answer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DFKnowledgeAnswers)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DFKnowledgeAnswers_Answer_MatchConfidenceLevel_RawValue(DFKnowledgeAnswers_Answer *message) {
  GPBDescriptor *descriptor = [DFKnowledgeAnswers_Answer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DFKnowledgeAnswers_Answer_FieldNumber_MatchConfidenceLevel];
  return GPBGetMessageInt32Field(message, field);
}

void SetDFKnowledgeAnswers_Answer_MatchConfidenceLevel_RawValue(DFKnowledgeAnswers_Answer *message, int32_t value) {
  GPBDescriptor *descriptor = [DFKnowledgeAnswers_Answer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DFKnowledgeAnswers_Answer_FieldNumber_MatchConfidenceLevel];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum DFKnowledgeAnswers_Answer_MatchConfidenceLevel

GPBEnumDescriptor *DFKnowledgeAnswers_Answer_MatchConfidenceLevel_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MatchConfidenceLevelUnspecified\000Low\000Medi"
        "um\000High\000";
    static const int32_t values[] = {
        DFKnowledgeAnswers_Answer_MatchConfidenceLevel_MatchConfidenceLevelUnspecified,
        DFKnowledgeAnswers_Answer_MatchConfidenceLevel_Low,
        DFKnowledgeAnswers_Answer_MatchConfidenceLevel_Medium,
        DFKnowledgeAnswers_Answer_MatchConfidenceLevel_High,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DFKnowledgeAnswers_Answer_MatchConfidenceLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DFKnowledgeAnswers_Answer_MatchConfidenceLevel_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DFKnowledgeAnswers_Answer_MatchConfidenceLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case DFKnowledgeAnswers_Answer_MatchConfidenceLevel_MatchConfidenceLevelUnspecified:
    case DFKnowledgeAnswers_Answer_MatchConfidenceLevel_Low:
    case DFKnowledgeAnswers_Answer_MatchConfidenceLevel_Medium:
    case DFKnowledgeAnswers_Answer_MatchConfidenceLevel_High:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DFStreamingDetectIntentRequest

@implementation DFStreamingDetectIntentRequest

@dynamic session;
@dynamic hasQueryParams, queryParams;
@dynamic hasQueryInput, queryInput;
@dynamic singleUtterance;
@dynamic hasOutputAudioConfig, outputAudioConfig;
@dynamic inputAudio;

typedef struct DFStreamingDetectIntentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *session;
  DFQueryParameters *queryParams;
  DFQueryInput *queryInput;
  DFOutputAudioConfig *outputAudioConfig;
  NSData *inputAudio;
} DFStreamingDetectIntentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingDetectIntentRequest_FieldNumber_Session,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "queryParams",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryParameters),
        .number = DFStreamingDetectIntentRequest_FieldNumber_QueryParams,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentRequest__storage_, queryParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queryInput",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryInput),
        .number = DFStreamingDetectIntentRequest_FieldNumber_QueryInput,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentRequest__storage_, queryInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "singleUtterance",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingDetectIntentRequest_FieldNumber_SingleUtterance,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "outputAudioConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(DFOutputAudioConfig),
        .number = DFStreamingDetectIntentRequest_FieldNumber_OutputAudioConfig,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentRequest__storage_, outputAudioConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inputAudio",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingDetectIntentRequest_FieldNumber_InputAudio,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentRequest__storage_, inputAudio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFStreamingDetectIntentRequest class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFStreamingDetectIntentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFStreamingDetectIntentResponse

@implementation DFStreamingDetectIntentResponse

@dynamic responseId;
@dynamic hasRecognitionResult, recognitionResult;
@dynamic hasQueryResult, queryResult;
@dynamic alternativeQueryResultsArray, alternativeQueryResultsArray_Count;
@dynamic hasWebhookStatus, webhookStatus;
@dynamic outputAudio;
@dynamic hasOutputAudioConfig, outputAudioConfig;

typedef struct DFStreamingDetectIntentResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *responseId;
  DFStreamingRecognitionResult *recognitionResult;
  DFQueryResult *queryResult;
  Status *webhookStatus;
  NSData *outputAudio;
  DFOutputAudioConfig *outputAudioConfig;
  NSMutableArray *alternativeQueryResultsArray;
} DFStreamingDetectIntentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseId",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingDetectIntentResponse_FieldNumber_ResponseId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, responseId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recognitionResult",
        .dataTypeSpecific.className = GPBStringifySymbol(DFStreamingRecognitionResult),
        .number = DFStreamingDetectIntentResponse_FieldNumber_RecognitionResult,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, recognitionResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queryResult",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryResult),
        .number = DFStreamingDetectIntentResponse_FieldNumber_QueryResult,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, queryResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webhookStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(Status),
        .number = DFStreamingDetectIntentResponse_FieldNumber_WebhookStatus,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, webhookStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputAudio",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingDetectIntentResponse_FieldNumber_OutputAudio,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, outputAudio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "outputAudioConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(DFOutputAudioConfig),
        .number = DFStreamingDetectIntentResponse_FieldNumber_OutputAudioConfig,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, outputAudioConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alternativeQueryResultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DFQueryResult),
        .number = DFStreamingDetectIntentResponse_FieldNumber_AlternativeQueryResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFStreamingDetectIntentResponse__storage_, alternativeQueryResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFStreamingDetectIntentResponse class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFStreamingDetectIntentResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFStreamingRecognitionResult

@implementation DFStreamingRecognitionResult

@dynamic messageType;
@dynamic transcript;
@dynamic isFinal;
@dynamic confidence;

typedef struct DFStreamingRecognitionResult__storage_ {
  uint32_t _has_storage_[1];
  DFStreamingRecognitionResult_MessageType messageType;
  float confidence;
  NSString *transcript;
} DFStreamingRecognitionResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageType",
        .dataTypeSpecific.enumDescFunc = DFStreamingRecognitionResult_MessageType_EnumDescriptor,
        .number = DFStreamingRecognitionResult_FieldNumber_MessageType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFStreamingRecognitionResult__storage_, messageType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transcript",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingRecognitionResult_FieldNumber_Transcript,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFStreamingRecognitionResult__storage_, transcript),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isFinal",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingRecognitionResult_FieldNumber_IsFinal,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = DFStreamingRecognitionResult_FieldNumber_Confidence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DFStreamingRecognitionResult__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFStreamingRecognitionResult class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFStreamingRecognitionResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DFStreamingRecognitionResult_MessageType_RawValue(DFStreamingRecognitionResult *message) {
  GPBDescriptor *descriptor = [DFStreamingRecognitionResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DFStreamingRecognitionResult_FieldNumber_MessageType];
  return GPBGetMessageInt32Field(message, field);
}

void SetDFStreamingRecognitionResult_MessageType_RawValue(DFStreamingRecognitionResult *message, int32_t value) {
  GPBDescriptor *descriptor = [DFStreamingRecognitionResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DFStreamingRecognitionResult_FieldNumber_MessageType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum DFStreamingRecognitionResult_MessageType

GPBEnumDescriptor *DFStreamingRecognitionResult_MessageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessageTypeUnspecified\000Transcript\000EndOfS"
        "ingleUtterance\000";
    static const int32_t values[] = {
        DFStreamingRecognitionResult_MessageType_MessageTypeUnspecified,
        DFStreamingRecognitionResult_MessageType_Transcript,
        DFStreamingRecognitionResult_MessageType_EndOfSingleUtterance,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DFStreamingRecognitionResult_MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DFStreamingRecognitionResult_MessageType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DFStreamingRecognitionResult_MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DFStreamingRecognitionResult_MessageType_MessageTypeUnspecified:
    case DFStreamingRecognitionResult_MessageType_Transcript:
    case DFStreamingRecognitionResult_MessageType_EndOfSingleUtterance:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DFInputAudioConfig

@implementation DFInputAudioConfig

@dynamic audioEncoding;
@dynamic sampleRateHertz;
@dynamic languageCode;
@dynamic phraseHintsArray, phraseHintsArray_Count;
@dynamic model;

typedef struct DFInputAudioConfig__storage_ {
  uint32_t _has_storage_[1];
  DFAudioEncoding audioEncoding;
  int32_t sampleRateHertz;
  NSString *languageCode;
  NSMutableArray *phraseHintsArray;
  NSString *model;
} DFInputAudioConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioEncoding",
        .dataTypeSpecific.enumDescFunc = DFAudioEncoding_EnumDescriptor,
        .number = DFInputAudioConfig_FieldNumber_AudioEncoding,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFInputAudioConfig__storage_, audioEncoding),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sampleRateHertz",
        .dataTypeSpecific.className = NULL,
        .number = DFInputAudioConfig_FieldNumber_SampleRateHertz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFInputAudioConfig__storage_, sampleRateHertz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = DFInputAudioConfig_FieldNumber_LanguageCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFInputAudioConfig__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phraseHintsArray",
        .dataTypeSpecific.className = NULL,
        .number = DFInputAudioConfig_FieldNumber_PhraseHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DFInputAudioConfig__storage_, phraseHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = DFInputAudioConfig_FieldNumber_Model,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DFInputAudioConfig__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFInputAudioConfig class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFInputAudioConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DFInputAudioConfig_AudioEncoding_RawValue(DFInputAudioConfig *message) {
  GPBDescriptor *descriptor = [DFInputAudioConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DFInputAudioConfig_FieldNumber_AudioEncoding];
  return GPBGetMessageInt32Field(message, field);
}

void SetDFInputAudioConfig_AudioEncoding_RawValue(DFInputAudioConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [DFInputAudioConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DFInputAudioConfig_FieldNumber_AudioEncoding];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DFTextInput

@implementation DFTextInput

@dynamic text;
@dynamic languageCode;

typedef struct DFTextInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  NSString *languageCode;
} DFTextInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = DFTextInput_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFTextInput__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = DFTextInput_FieldNumber_LanguageCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFTextInput__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFTextInput class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFTextInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFEventInput

@implementation DFEventInput

@dynamic name;
@dynamic hasParameters, parameters;
@dynamic languageCode;

typedef struct DFEventInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GPBStruct *parameters;
  NSString *languageCode;
} DFEventInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = DFEventInput_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFEventInput__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parameters",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = DFEventInput_FieldNumber_Parameters,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFEventInput__storage_, parameters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = DFEventInput_FieldNumber_LanguageCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DFEventInput__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFEventInput class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFEventInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFSentimentAnalysisRequestConfig

@implementation DFSentimentAnalysisRequestConfig

@dynamic analyzeQueryTextSentiment;

typedef struct DFSentimentAnalysisRequestConfig__storage_ {
  uint32_t _has_storage_[1];
} DFSentimentAnalysisRequestConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "analyzeQueryTextSentiment",
        .dataTypeSpecific.className = NULL,
        .number = DFSentimentAnalysisRequestConfig_FieldNumber_AnalyzeQueryTextSentiment,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFSentimentAnalysisRequestConfig class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFSentimentAnalysisRequestConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFSentimentAnalysisResult

@implementation DFSentimentAnalysisResult

@dynamic hasQueryTextSentiment, queryTextSentiment;

typedef struct DFSentimentAnalysisResult__storage_ {
  uint32_t _has_storage_[1];
  DFSentiment *queryTextSentiment;
} DFSentimentAnalysisResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryTextSentiment",
        .dataTypeSpecific.className = GPBStringifySymbol(DFSentiment),
        .number = DFSentimentAnalysisResult_FieldNumber_QueryTextSentiment,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFSentimentAnalysisResult__storage_, queryTextSentiment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFSentimentAnalysisResult class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFSentimentAnalysisResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DFSentiment

@implementation DFSentiment

@dynamic score;
@dynamic magnitude;

typedef struct DFSentiment__storage_ {
  uint32_t _has_storage_[1];
  float score;
  float magnitude;
} DFSentiment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = DFSentiment_FieldNumber_Score,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DFSentiment__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "magnitude",
        .dataTypeSpecific.className = NULL,
        .number = DFSentiment_FieldNumber_Magnitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DFSentiment__storage_, magnitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DFSentiment class]
                                     rootClass:[DFSessionRoot class]
                                          file:DFSessionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DFSentiment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
